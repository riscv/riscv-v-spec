= Vector extension
Version 0.5-draft 20181011
:doctype: article
:encoding: utf-8
:lang: en
:toc: left
:numbered:

== Background and Motivation

WARNING: This is a draft of the RISC-V Vector Extension and is likely
to change substantially before standardization.

WARNING: Even this version is a little behind current discussion, will
catch up to be primary reference soon.

NOTE:  Contributors: Krste Asanovic, Roger Espasa, Alon Amid, Rich Newell, Albert Ou, Colin Schmidt, Steve Wallach, plus many more to be added

== Vector CSRs

=== `vcfg` CSR

The `vcfg` CSR holds `vregcfg`, `vemaxw`, and `vtypeen`.

==== `vregcfg[6:0]`

`vregcfg` uses a 7-bit encoding to configure the number of vector
registers along with their element widths.

The upper bits (`vregmax`) correspond to the maximum number of
architectural vector registers available, alternatively interpreted to
be a "vector length multiplier".

----
vlenmul = floor(32 / vregmax)
----

The lower bits (`vregsel`) denote a configuration as a set of
single-word (`s`), double-word (`d`), and quad-word (`q`) vector
registers conceptually mapped to `vregmax` units of storage.
`s` registers have `vemaxw`-bit elements.
Wider `d` and `q` vector registers are created by combining two or
four logically adjacent `s` registers, respectively.

These combined registers are aligned such that their number is divisible by
two for `d` and by four for `q` registers.
The other `s` registers that are combined to form the larger register cannot
be used in isolation: if `vN` is double-word then instructions that read or
write `v(N+1)` raise an illegal instruction exception, and likewise if `vN` is
quad-word then instructions that read or write any of `v(N+1)`, `v(N+2)` and
`v(N+3)` raise an illegal instruction exception.

It is always possible to construct a homogenous register file of a wider
element type by setting a larger `vemaxw` as the base width.
`v0` always holds the smallest type for use in masking.

These conditions determine the complete set of theoretically possible
`(s, d, q)` configurations, of which not all have valid encodings due to
limited `vregcfg` state:

----
s + 2d + 4q = vregmax
1 <= s <= vregmax
0 <= d <= max(floor(vregmax / 2) - 1, 0)
0 <= q <= max(floor(vregmax / 4) - 1, 0)
----

[cols="3*>1,^2", options="header"]
|===
|`vregmax`
|`vlenmul`
|#Configurations
|Prefix

|32
|1
|72
|`00-----`

|16
|2
|20
|`01-----`

|10
|3
|8
|`100----`

|8
|4
|6
|`101----`

|6
|5
|3
|`1100---`

|5
|6
|2
|`1101---`

|4
|8
|2
|`11100--`

|3
|10
|1
|`11101--`

|2
|16
|1
|`11110--`

|1
|32
|1
|`11111--`

|===

[NOTE]
*Rationale for variable-length prefix encoding*:
The number of theoretical combinations grows roughly quadratically with
`vregmax`, so the number of bits for `vregsel` should scale linearly.
This permits the complete set of configurations for `vregmax \<= 16` to be
encoded, while reserving space to encode the 32 most useful combinations
for `vregmax = 32`.

[IMPORTANT]
A `vregcfg` value of `0x7f` indicates that the vector unit is disabled.

[cols=">1,^2,<8", options="header"]
|===
^|`vregmax`
^|Encoding
^|Register mapping (`v0`...`v31`)

.32+|32
^|`00 00 000` <|`s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s`
^|`00 00 001` <|`s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s d -`
^|`00 00 010` <|`s s s s s s s s s s s s s s s s s s s s s s s s s s s s d - d -`
^|`00 00 011` <|`s s s s s s s s s s s s s s s s s s s s s s s s s s d - d - d -`
^|`00 00 100` <|`s s s s s s s s s s s s s s s s s s s s s s s s d - d - d - d -`
^|`00 00 101` <|`s s s s s s s s s s s s s s s s s s s s s s d - d - d - d - d -`
^|`00 00 110` <|`s s s s s s s s s s s s s s s s s s s s d - d - d - d - d - d -`
^|`00 00 111` <|`s s s s s s s s s s s s s s s s s s d - d - d - d - d - d - d -`

^|`00 01 000` <|`s s s s s s s s s s s s s s s s s s s s s s s s s s s s q - - -`
^|`00 01 001` <|`s s s s s s s s s s s s s s s s s s s s s s s s s s d - q - - -`
^|`00 01 010` <|`s s s s s s s s s s s s s s s s s s s s s s s s d - d - q - - -`
^|`00 01 011` <|`s s s s s s s s s s s s s s s s s s s s s s d - d - d - q - - -`
^|`00 01 100` <|`s s s s s s s s s s s s s s s s s s s s d - d - d - d - q - - -`
^|`00 01 101` <|`s s s s s s s s s s s s s s s s s s d - d - d - d - d - q - - -`
^|`00 01 110` <|`s s s s s s s s s s s s s s s s d - d - d - d - d - d - q - - -`
^|`00 01 111` <|`s s s s s s s s s s s s s s d - d - d - d - d - d - d - q - - -`

^|`00 10 000` <|`s s s s s s s s s s s s s s s s s s s s s s s s q - - - q - - -`
^|`00 10 001` <|`s s s s s s s s s s s s s s s s s s s s s s d - q - - - q - - -`
^|`00 10 010` <|`s s s s s s s s s s s s s s s s s s s s d - d - q - - - q - - -`
^|`00 10 011` <|`s s s s s s s s s s s s s s s s s s d - d - d - q - - - q - - -`
^|`00 10 100` <|`s s s s s s s s s s s s s s s s d - d - d - d - q - - - q - - -`
^|`00 10 101` <|`s s s s s s s s s s s s s s d - d - d - d - d - q - - - q - - -`
^|`00 10 110` <|`s s s s s s s s s s s s d - d - d - d - d - d - q - - - q - - -`
^|`00 10 111` <|`s s s s s s s s s s d - d - d - d - d - d - d - q - - - q - - -`

^|`00 11 000` <|`s s s s s s s s s s s s s s s s s s s s q - - - q - - - q - - -`
^|`00 11 001` <|`s s s s s s s s s s s s s s s s s s d - q - - - q - - - q - - -`
^|`00 11 010` <|`s s s s s s s s s s s s s s s s d - d - q - - - q - - - q - - -`
^|`00 11 011` <|`s s s s s s s s s s s s s s d - d - d - q - - - q - - - q - - -`
^|`00 11 100` <|`s s s s s s s s s s s s d - d - d - d - q - - - q - - - q - - -`
^|`00 11 101` <|`s s s s s s s s s s d - d - d - d - d - q - - - q - - - q - - -`
^|`00 11 110` <|`s s s s s s s s d - d - d - d - d - d - q - - - q - - - q - - -`
^|`00 11 111` <|`s s s s s s d - d - d - d - d - d - d - q - - - q - - - q - - -`

.20+|16
^|`01 00 000` <|`s s s s s s s s s s s s s s s s`
^|`01 00 001` <|`s s s s s s s s s s s s s s d -`
^|`01 00 010` <|`s s s s s s s s s s s s d - d -`
^|`01 00 011` <|`s s s s s s s s s s d - d - d -`
^|`01 00 100` <|`s s s s s s s s d - d - d - d -`
^|`01 00 101` <|`s s s s s s d - d - d - d - d -`
^|`01 00 110` <|`s s s s d - d - d - d - d - d -`
^|`01 00 111` <|`s s d - d - d - d - d - d - d -`

^|`01 01 000` <|`s s s s s s s s s s s s q - - -`
^|`01 01 001` <|`s s s s s s s s s s d - q - - -`
^|`01 01 010` <|`s s s s s s s s d - d - q - - -`
^|`01 01 011` <|`s s s s s s d - d - d - q - - -`
^|`01 01 100` <|`s s s s d - d - d - d - q - - -`
^|`01 01 101` <|`s s d - d - d - d - d - q - - -`

^|`01 10 000` <|`s s s s s s s s q - - - q - - -`
^|`01 10 001` <|`s s s s s s d - q - - - q - - -`
^|`01 10 010` <|`s s s s d - d - q - - - q - - -`
^|`01 10 011` <|`s s d - d - d - q - - - q - - -`

^|`01 11 000` <|`s s s s q - - - q - - - q - - -`
^|`01 11 001` <|`s s d - q - - - q - - - q - - -`

.8+|10
^|`100 0 000` <|`s s s s s s s s s s`
^|`100 0 001` <|`s s s s s s s s d -`
^|`100 0 010` <|`s s s s s s d - d -`
^|`100 0 011` <|`s s s s d - d - d -`
^|`100 0 100` <|`s s d - d - d - d -`
^|`100 1 000` <|`s s s s q - - - s s`
^|`100 1 001` <|`s s s s q - - - d -`
^|`100 1 010` <|`s s d - q - - - d -`

.6+|8
^|`101 0 000` <|`s s s s s s s s`
^|`101 0 001` <|`s s s s s s d -`
^|`101 0 010` <|`s s s s d - d -`
^|`101 0 011` <|`s s d - d - d -`
^|`101 1 000` <|`s s s s q - - -`
^|`101 1 001` <|`s s d - q - - -`

.3+|6
^|`1100  000` <|`s s s s s s`
^|`1100  001` <|`s s s s d -`
^|`1100  010` <|`s s d - d -`

.2+|5
^|`1101  000` <|`s s s s s`
^|`1101  001` <|`s s d - s`

.2+|4
^|`11100  00` <|`s s s s`
^|`11100  01` <|`s s d -`

|3
|`11101  00` |`s s s`

|2
|`11110  00` |`s s`

|1
|`11111  00` |`s`

|===

[NOTE]
`vregsel[2:0]` encodes the number of `d` registers, and
`vregsel[4:3]` encodes the number of `q` registers
(if the `vregsel` bits that overlap with the `vregmax` prefix are
implicitly treated as zero).

==== `vemaxw[5:3]`

`vemaxw` is a 3-bit `WARL` field that can be expanded to match the
`vew[5:0]` expanded width encoding.

----
001     8-bit
010     16-bit
011     32-bit
100     64-bit
----

This aligns with expanded `vew<n>` encoding and leaves `WARL` space to
support other max element widths.

==== `vtypeen`

`vtypeen` is a single-bit `WARL` field that indicates `vtype` CSRs are
being used.
It can be hardwired to zero if vtypes not supported.
Further details about `vtype` CSRs can be found in <<VTypes>> 


=== `vl[XLEN-1:0]` CSR

`vl` is a `WARL` CSR that holds the current active vector length.

=== `vlmax[XLEN-1:0]` CSR

`vlmax` is a read-only CSR that holds the current maximum hardware
vector length (`MAXVL`).

This is primarily intended to assist context switching by simplifying
size calculations for memory allocation.

[NOTE]
We can compute `MAXVL` using the `vsetvl` instruction with a requested vector 
length of 2\^xlen - 1 (the equivalent of "infinity")

=== `vregmask[31:0]` CSR

`vregmask` is a read-only CSR that indicates which vector registers are
enabled under the current configuration.
Bitfield `vregmask[0]` is set if `v0` is a legal register, `vregmask[1]` for
`v1`, and so on.

This is primarily intended to simplify context switching, so software
can determine which registers must be saved without needing to decode
`vregcfg` itself.

=== `vxcfg` CSR holds `vxrm` and `vxcm`

==== `vxrm[1:0]`

Holds fixed-point rounding mode.

----
00      trn truncate
01      jam jam (OR bits into LSB)
10      rne round to nearest-even
11      rup round-up (+0.5 LSB)
----

==== `vxcm`
Holds fixed-point clipping mode

----
    0 wraparound
    1 saturate
----

==== `vxsat`  (in `fcsr`)

Holds sticky fixed-point saturation flag.  Set if any `vclip` or `vclipi`
instruction causes saturation.

[NOTE]
Should also pack all `vcsr` fields into `fcsr` for reduced context switch time?

== Vector Configuration Instructions

=== `vconfig` instruction

Could use `li` + `csrw` instructions to write `vcfg`, or have a `vconfig`
instruction with an 8-bit `vregcfg` immediate field to enable setting a
base configuration in a single instruction.

[NOTE]
Don't need `vtypen` in base instruction.

The system calculates a `MAXVL` based on the `vconfig` settings, and the
vector length `vl` CSR is initialized to `MAXVL`.

[NOTE]
All vector registers are initialized to zero by a `vconfig` instruction.

A pseudo-instruction `vdisable` is mapped to `vconfig` with immediate
bits `0x7f`, resulting in `vregmax = 0` and `vl = 0`.

[IMPORTANT]
`vregcfg[7] = 0` for all cases, since `vregcfg[6:0]`
suffices to encode all legal configurations required in the base.
All instances of `vregcfg[7] = 1` are reserved for future use.

=== `vl` and `vsetvl` instruction

The `vsetvl rd, rs1` instruction sets `vl` based on the current vector
configuration and the value in `rs1` treated as an unsigned integer, and
also writes this value to `rd`.

The `vl` setting must be:

. greater than 0, if rs1 is greater than 0
. monotonically increasing with the value in rs1, but need not be
strictly increasing
. bounded above by min(rs1,MAXVL) 
. deterministic for any given configuration

If the vector unit is disabled, vsetvl or any read or write of `vl` will
raise an illegal instruction exception.

The vsetvl instruction is not encoded as a regular `CSRRW` instruction
as the value returned depends on the input value.

Regular CSR instructions can be used to read and write `vl`.

Changing the value of the `vl` register (either using `vsetvl` or using `CSRRW`)
does not mutate the register file state. i.e. - values in the register file are preserved.

[NOTE]
It is sufficient to make `vl` a read-only register, since the `vsetvl` instruction
can be used to re-populate the register during context swaps.

The value written to `vl` on a CSR write is capped at `MAXVL` (`vl` is `WARL`).

== Vector instruction overview

In the base vector extension, all source vector register operands are
treated as vectors of elements, but the destination vector registers
can be either written with a vector of results (a vector shape), or
with a single scalar value replicated in each vector element position
(a scalar shape).  This approach avoids the need for explicit
vector-scalar instructions and is upwards-compatible with shape
encoding in future vector extensions.  Scalar shapes are intended to
be microarchitecturally optimized so that only a single value is
actually written/read.

Simple vector instructions that produce scalar shapes will only use
`element[0]` of the source vectors as inputs to the computation, but will
effectively write all elements of the destination vector. A few vector
instructions perform reductions across source vectors to produce a
scalar shape.

The active vector length in `vl` determines the number of elements
processed by each vector instruction.  Instructions producing vector
shape results, write zero to destination vector elements past the end
of vl.  Instructions producing scalar shapes, write the scalar to all
MAXVL elements of the destination vector register regardless of `vl`
setting.

Masking is supported on almost all vector instructions producing
vectors, with the mask supplied by vector register `v0`.  The `LSB` of
each element in `v0` is used as the mask, in either true or complement
form.  Element operations that are masked off can never generate exceptions.
Instructions writing vector shapes, write zero to the destination
elements that are masked off. Instructions producing scalar shapes are
not maskable.

The scalar/vector shape of the result and the type of masking are
encoded in a two-bit `m[1:0]` field (`inst[26:25]`) for most vector
instructions.

`m[1:0]` encoding of "masked-on" condition

----
00 scalar, always true
01 vector, always true
10 vector, where v0.LSB = 0
11 vector, where v0.LSB = 1
----

(Might prefer swapping true/false encoding for 10/11)

=== Assembler syntax

Scalar shape destinations are written in assembler with a `.s` after the
destination vector register specifier.
Vector masking is written as another vector operand, with `.t` or `.f` indicating if operation occurs
when `v0.LSB` is `1` or `0` respectively.
If no masking operand is specified, unmasked vector execution (`m=01`) is assumed.

`vadd v0, v2, v3, vm` implies following combinations:

[source,asm]
----
    vadd    v0.s, v2, v3        # scalar shape destination,  m=00
    vadd    v0,   v2, v3        # unmasked vector operation, m=01
    vadd    v0,   v2, v3, v0.f  # enabled where v0.LSB=0,    m=10
    vadd    v0,   v2, v3, v0.t  # enabled where v0.LSB=1,    m=11
----


=== Vtypes
This is a place holder for an explanation regarding polymorphic instructions when the vtypes
option is enabled.


=== Operations and Types

The following is a table of operations, and the affect of the operand and destination types on the result of the operations.

The table makes several assumptions:

. Source operands cannot be a mix of floating point and integers
. Source operands can be of different widths, but with a difference of no more than a single factor of 2
. An instruction with a "00" mask value ("scalar destination indication") with a non-scalar vtypes destination register shape is illegal (should trap)
. An instruction with a mask value which is not "00" ("vector destination indication") with a scalar vtypes destination register shape is illegal (should trap)
. AMO operands must be of the same shape (trap otherwise)
. The types are described as follows:

	I - Integer

	F - Floating Point

	S/U - Signed/Unsigned

	B - Bits 

[format="csv", separator=",", options="header"]
|===
Base/Vtypes,Mnemonic,Category,V operands,G operands,Description,Src Type,Dst Type (dst_width = src_width),Dst Type (dst_width = 2*src_width),Dst Type (dst_width = src_width / 2),"Dst Vector/Scalar Behavior: vector src, scalar dst (instruction mask bits = 00 or scalar shape when vtypes is enabled)","Dst Scalar/Vector Behavior: vector dst, scalar src (src was written previously as a scalar using 00 mask bits)"
Vtypes,VADD,arith,2,0,add,"S/U,F","S/U,F",S/U,ILLEGAL,Reduction,Splat
Base,VADD.X,arith,2,0,add,S/U,S/U,ILLEGAL,ILLEGAL,First Element,Splat
Base,"VFADD.[H,S,D]",arith,2,0,add,F,F,ILLEGAL,ILLEGAL,First Element,Splat
Vtypes,VADDI,arith,1,0,add immediate,S/U,S/U,S/U,ILLEGAL,Reduction,Splat
Base,VADDI.X,arith,1,0,add immediate,S/U,S/U,ILLEGAL,ILLEGAL,First Element,Splat
Base,VPOPC,arith,1,0,count bits set,I,I,ILLEGAL,ILLEGAL,First Element,Splat
Vtypes,VSUB,arith,2,0,subtract,"S/U,F","S/U,F",S/U,ILLEGAL,First Element,Splat
Base,VSUB.X,arith,2,0,subtract,I,I,ILLEGAL,ILLEGAL,First Element,Splat
Base,"VFSUB.[H,S,D]",arith,2,0,subtract,F,F,ILLEGAL,ILLEGAL,First Element,Splat
Vtypes,VSEQ,compare,2,0,"1 if ==, else 0","S/U,F",ן,I,ILLEGAL,First Element,Splat
Base,VSEQ.X,compare,2,0,"1 if ==, else 0",S/U,I,I,ILLEGAL,First Element,Splat
Base,VFSEQ.[H.S.D],compare,2,0,"1 if ==, else 0",F,I,I,ILLEGAL,First Element,Splat
Vtypes,VSGE,compare,2,0,"1 if >=, else 0","S/U,F",I,I,ILLEGAL,First Element,Splat
Base,VSGE.X,compare,2,0,"1 if >=, else 0",S/U,I,I,ILLEGAL,First Element,Splat
Base,"VFSGE.[H,S,D]",compare,2,0,"1 if >=, else 0",F,I,I,ILLEGAL,First Element,Splat
Vtypes,VSLT,compare,2,0,"1 if <, else 0","S/U,F",ן,I,ILLEGAL,First Element,Splat
Base,VSLT.X,compare,2,0,"1 if <, else 0",S/U,ן,I,ILLEGAL,First Element,Splat
Base,"VFSLT.[H,S,D]",compare,2,0,"1 if <, else 0",F,ן,I,ILLEGAL,First Element,Splat
Vtypes,VSNE,compare,2,0,"1 if <>, else 0","S/U,F",ן,I,ILLEGAL,First Element,Splat
Base,VSNE.X,compare,2,0,"1 if <>, else 0",S/U,ן,I,ILLEGAL,First Element,Splat
Base,"VFSNE.[H,S,D]",compare,2,0,"1 if <>, else 0",F,ן,I,ILLEGAL,First Element,Splat
Vtypes,VCVT,convert,1,1,convert type,"S/U,F","F,S/U",ILLEGAL,ILLEGAL,First Element,Splat
Base,"VFCVT.[X,H,S,D].[X,H,S,D]",convert,1,1,convert type,"S/U,F","F,S/U",ILLEGAL,ILLEGAL,First Element,Splat
Vtypes,VSGNJ,copy/sign,2,0,FP sign injection,F,F,ILLEGAL,ILLEGAL,First Element,Splat
Base,"VFSGNJ.[H,S,D]",copy/sign,2,0,FP sign injection,F,F,ILLEGAL,ILLEGAL,First Element,Splat
Vtypes,VSGNJN,copy/sign,2,0,FP inverted sign injection,F,F,ILLEGAL,ILLEGAL,First Element,Splat
Base,"VFSGNJN.[H,S,D]",copy/sign,2,0,FP inverted sign injection,F,F,ILLEGAL,ILLEGAL,First Element,Splat
Vtypes,VSGNJX,copy/sign,2,0,FP xor sign,F,F,ILLEGAL,ILLEGAL,First Element,Splat
Base,"VFSGNJX.[H,S,D]",copy/sign,2,0,FP xor sign,F,F,ILLEGAL,ILLEGAL,First Element,Splat
Vtypes,VDIV,divsqrt,2,0,divide,F,F,ILLEGAL,ILLEGAL,First Element,Splat
Base,"VFDIV[H,S,D]",divsqrt,2,0,divide,F,F,ILLEGAL,ILLEGAL,First Element,Splat
Vtypes,VREM,divsqrt,2,0,partial remainder,F,F,ILLEGAL,ILLEGAL,First Element,Splat
Base,"VFREM.[H,S,D]",divsqrt,2,0,partial remainder,F,F,ILLEGAL,ILLEGAL,First Element,Splat
Vtypes,VSQRT,divsqrt,1,0,square root,F,F,ILLEGAL,ILLEGAL,First Element,Splat
Base,"VFSQRT.[H,S,D]",divsqrt,1,0,square root,F,F,ILLEGAL,ILLEGAL,First Element,Splat
Vtypes,VCLASS,identify FP,1,0,"FP value class (e.g., 0, inf)",F,F,ILLEGAL,ILLEGAL,First Element,Splat
Base,"VFCLASS.[H,S,D]",identify FP,1,0,"FP value class (e.g., 0, inf)",F,F,ILLEGAL,ILLEGAL,First Element,Splat
Vtypes,VL,load,0,1,load vector (unit stride),I,B/F,ILLEGAL,ILLEGAL,First Element,Splat
Base,"VL.[B,H,W,D][U]",load,0,1,load vector (unit stride),I,B,ILLEGAL,ILLEGAL,First Element,Splat
Base,"VFL.[H,S,D]",load,0,1,load vector (unit stride),I,F,ILLEGAL,ILLEGAL,First Element,Splat
Vtypes,VLS,load,0,2,load vector (stride),I,B/F,ILLEGAL,ILLEGAL,First Element,Splat
Base,"VLS.[B,H,W,D][U]",load,0,2,load vector (stride),I,B,ILLEGAL,ILLEGAL,First Element,Splat
Base,"VFLS.[H,S,D]",load,0,2,load vector (stride),I,F,ILLEGAL,ILLEGAL,First Element,Splat
Vtypes,VLX,load,1,1,load vector indexed (gather),I,B/F,ILLEGAL,ILLEGAL,First Element,Splat
Base,"VLX.[B,H,W,D][U]",load,1,1,load vector indexed (gather),I,B,ILLEGAL,ILLEGAL,First Element,Splat
Base,"VFLX.[H,S,D]",load,1,1,load vector indexed (gather),I,F,ILLEGAL,ILLEGAL,First Element,Splat
Vtypes,VLO,load,0,1,load vector ordered,I,B/F,ILLEGAL,ILLEGAL,First Element,Splat
Base,VAND,logical,2,0,bitwise AND,B,B,ILLEGAL,ILLEGAL,Reduction,Splat
Base,VANDI,logical,1,0,bitwise AND with immediate,B,B,ILLEGAL,ILLEGAL,Reduction,Splat
Base,VOR,logical,2,0,bitwise OR,B,B,ILLEGAL,ILLEGAL,Reduction,Splat
Base,VORI,logical,1,0,bitwise OR with immediate,B,B,ILLEGAL,ILLEGAL,Reduction,Splat
Base,VXOR,logical,2,0,bitwise XOR,B,B,ILLEGAL,ILLEGAL,Reduction,Splat
Base,VXORI,logical,1,0,bitwise XOR with immediate,B,B,ILLEGAL,ILLEGAL,Reduction,Splat
Base,VMFIRST,mask,1,0,index of first TRUE lab -> GPR,B,B,ILLEGAL,ILLEGAL,GPR,Splat
Base,VMPOP,mask,1,0,Count lsb of elements -> GPR,B,B,ILLEGAL,ILLEGAL,GPR,Splat
Vtypes,VMADD,multiply-add,3,0,Multiply add,"S/U,F","S/U,F","I,F",ILLEGAL,Reduction,Splat
Base,"VFMADD.[H,S,D]",multiply-add,3,0,Multiply add,F,F,F,ILLEGAL,First Element,Splat
Vtypes,VMSUB,multiply-add,3,0,Multiply subtract,"S/U,F","S/U,F","I,F",ILLEGAL,Reduction,Splat
Base,"VFMSUB.[H,S,D]",multiply-add,3,0,Multiply subtract,F,F,F,ILLEGAL,First Element,Splat
Vtypes,VMUL,multiply-add,2,0,Multiply,"S/U,F","S/U,F","S/U,F",ILLEGAL,Reduction,Splat
Base,VMUL.X,multiply-add,2,0,Multiply,S/U,S/U,ILLEGAL,ILLEGAL,First Element,Splat
Base,"VFMUL.[H,S,D]",multiply-add,2,0,Multiply,F,F,ILLEGAL,ILLEGAL,First Element,Splat
Vtypes,VMULH,multiply-add,2,0,Multiply - return high half,S/U,S/U,ILLEGAL,S/U,Reduction,Splat
Base,VMULH.X,multiply-add,2,0,Multiply - return high half,S/U,S/U,ILLEGAL,S/U,First Element,Splat
Vtypes,VNMADD,multiply-add,3,0,negated multiply add,"S/U,F","S/U,F","S/U,F",ILLEGAL,Reduction,Splat
Vtypes,VNMSUB,multiply-add,3,0,negated multiply sub,"S/U,F","S/U,F","S/U,F",ILLEGAL,ILLEGAL,Splat
Base,VEXTRACT,permute,1,1,extract element -> GPR,B,B,ILLEGAL,ILLEGAL,GPR,N/A
Base,VINSERT,permute,1,1,insert element(s),B,B,ILLEGAL,ILLEGAL,First Element,Placement
Base,VMERGE,permute,2,0,merge registers,B,B,ILLEGAL,ILLEGAL,First Element,Splat
Base,VSELECT,permute,2,0,select from source by indicies,B,B,ILLEGAL,ILLEGAL,First Element,Splat
Base,VSLIDE,permute,1,1,shift elements,B,B,ILLEGAL,ILLEGAL,First Element,Splat
Base,VCLIP,round,1,1,clip to narrow,S/U,S/U,ILLEGAL,S/U,First Element,Splat
Base,VCLIPI,round,1,0,"Clip, shift by imm",S/U,S/U,ILLEGAL,S/U,First Element,Splat
Vtypes,VMAX,select,2,0,return max element,"S/U,F","S/U,F",ILLEGAL,ILLEGAL,Reduction,Splat
Base,VMAX.X,select,2,0,return max element,S/U,S/U,ILLEGAL,ILLEGAL,First Element,Splat
Base,"VFMAX.[H,S,D]",select,2,0,return max element,F,F,ILLEGAL,ILLEGAL,First Element,Splat
Vtypes,VMIN,select,2,0,return min element,"S/U,F","S/U,F",ILLEGAL,ILLEGAL,Reduction,Splat
Base,VMIN.X,select,2,0,return min element,S/U,S/U,ILLEGAL,ILLEGAL,First Element,Splat
Base,"VFMIN.[H,S,D]",select,2,0,return min element,F,F,ILLEGAL,ILLEGAL,First Element,Splat
Base,VSL,shift,2,0,Shift Left,I,B,ILLEGAL,ILLEGAL,First Element,Splat
Base,VSLI,shift,1,0,shift left by immediate,I,B,ILLEGAL,ILLEGAL,First Element,Splat
Base,VSR,shift,2,0,Shift Right (arithmetic),I,B,ILLEGAL,ILLEGAL,First Element,Splat
Base,VSRI,shift,1,0,shift right by immediate,I,B,ILLEGAL,ILLEGAL,First Element,Splat
Vtypes,VS,store,0,1,store vector (unit stride),I,"B,F",ILLEGAL,ILLEGAL,First Element,Splat
Base,"VS.[B,H,W,D][U]",store,0,1,store vector (unit stride),I,B,ILLEGAL,ILLEGAL,First Element,Write a single value
Vtypes,VSS,store,0,2,store vector (stride),I,"B,F",ILLEGAL,ILLEGAL,First Element,Write a single value
Base,"VSS.[B,H,W,D][U]",store,0,2,store vector (stride),I,B,ILLEGAL,ILLEGAL,First Element,Write a single value
Vtypes,VSX,store,1,1,store vector indexed (scatter),I,"B,F",ILLEGAL,ILLEGAL,First Element,Write a single value
Base,"VSX.[B,H,W,D][U]",store,1,1,store vector indexed (scatter),I,B,ILLEGAL,ILLEGAL,First Element,Write a single value (first value of index vector)
Vtypes,VSO,store,0,1,store vector ordered,I,"B,F",ILLEGAL,ILLEGAL,First Element,Write a single value
Vtypes,VAMOADD,xAtomic:arith,2,0,Atomic: VAdd,S/U,S/U,ILLEGAL,ILLEGAL,Reduction,ILLEGAL
Vtypes,VAMOAND,xAtomic:logical,2,0,Atomic: AND,B,B,ILLEGAL,ILLEGAL,Reduction,ILLEGAL
Vtypes,VAMOOR,xAtomic:logical,2,0,Atomic: OR,B,B,ILLEGAL,ILLEGAL,Reduction,ILLEGAL
Vtypes,VAMOXOR,xAtomic:logical,2,0,Atomic: XOR,B,B,ILLEGAL,ILLEGAL,Reduction,ILLEGAL
Vtypes,VAMOMAX,xAtomic:select,2,0,Atomic: Vmax,S/U,S/U,ILLEGAL,ILLEGAL,Reduction,ILLEGAL
Vtypes,VAMOMIN,xAtomic:select,2,0,Atomic: VMin,S/U,S/U,ILLEGAL,ILLEGAL,Reduction,ILLEGAL
Vtypes,VAMOSWAP,xAtomic:swap,2,0,Atomic: VSwap,B,B,ILLEGAL,ILLEGAL,First Element,ILLEGAL
|=== 


== Integer Compute Instructions

=== Arithmetic instructions, general formats
==== Unary operations
[source,asm]
----
    vop     vd.s, vs1
    vop     vd,   vs1
    vop     vd,   vs1, v0.t
    vop     vd,   vs1, v0.f
----

==== Binary register-register operations
[source,asm]
----
    vop     vd.s, vs1, vs2
    vop     vd,   vs1, vs2
    vop     vd,   vs1, vs2, v0.t
    vop     vd,   vs1, vs2, v0.f
----

==== Binary register-immediate operations
[source,asm]
----
    vopi    vd.s,   vs1, imm
    vopi    vd,     vs1, imm
    vopi    vd,     vs1, imm, v0.t
    vopi    vd,     vs1, imm, v0.f
----

==== Ternary register-register operations
[source,asm]
----
    vop     vd.s,   vs1, vs2, vs3
    vop     vd,     vs1, vs2, vs3
    vop     vd,     vs1, vs2, vs3, v0.t
    vop     vd,     vs1, vs2, vs3, v0.f
----

=== Vector integer arithmetic instructions

Vector integer arithmetic instructions use the full vemaxw width of
the source and destination vector registers.  All vector integer
arithmetic instructions can produce scalar or vector shapes and can be
masked.

[source,asm]
----
    vadd    vd, vs1, vs2, v0.t
    vsub    vd, vs1, vs2, v0.t
    
    vsll    vd, vs1, vs2, v0.t
    vsra    vd, vs1, vs2, v0.t
    vsrl    vd, vs1, vs2, v0.t
    
    vand    vd, vs1, vs2, v0.t
    vor     vd, vs1, vs2, v0.t
    vxor    vd, vs1, vs2, v0.t
----

[NOTE]
`SNE` not needed with complementing masks

[source,asm]
----
    vseq    vd, vs1, vs2, v0.t
    vslt    vd, vs1, vs2, v0.t
    vsltu   vd, vs1, vs2, v0.t
    vsge    vd, vs1, vs2, v0.t
    vsgeu   vd, vs1, vs2, v0.t
----


These conditionals effectively `AND` in the mask when producing `0`/`1` in
output, e.g,

[source,asm]
----
    # (a < b) && (b < c) in two instructions
    vslt    v0, va, vb
    vslt    v0, vb, vc, v0.t
----

=== Binary register-immediate operations
These replace vs2 with a short sign-extended immediate (size TBD).
[source,asm]
----
    vaddi   vd, vs1, imm, v0.t

    vslli   vd, vs1, imm, v0.t
    vsrli   vd, vs1, imm, v0.t
    vsrai   vd, vs1, imm, v0.t

    vandi   vd, vs1, imm, v0.t
    vori    vd, vs1, imm, v0.t
    vxori   vd, vs1, imm, v0.t
----

== Vector Load/Store Instructions

Vector unit-stride, constant-stride, and indexed (scatter/gather) load/store instructions are supported.
Vector AMO instructions are not provided in the base vector extension.

Load instructions encode the type of the operand, while store instructions encode only the bit width.

Vector loads to a scalar shape only load one element from memory at
the same memory address that would be used for vector shape element 0.
Vector masked loads of vector shapes must not generate architecturally
visible side-effects (beyond writing zero to the destination element)
for masked-off elements.

Vector stores of a scalar shape store only one element to memory at
the same memory address that would be used for vector shape element 0.
Vector masked stores of vector shapes must not generate
architecturally visible side-effects for masked-off elements.

=== Vector memory model

Vector memory instructions appear to execute in program order on the
local hart.  Vector memory instructions follow RVWMO at the
instruction level, and element operations are ordered within the
instruction as if performed by an element-ordered sequence of
syntactically independent scalar instructions.  Vector indexed-ordered
stores write elements to memory in element order.

[NOTE]
Other possible vector indexed store instructions include unordered
and reverse-ordered.  Vector indexed-unordered stores write elements
to memory in arbitrary order within the vector instruction. Vector
indexed reverse-ordered writes elements in reverse element order to
help with vectorized memory alias disambiguation.

=== Integer vector load

Integer vector load instructions encode bit width and signed/unsigned
extension, similar to base scalar ISA.  Vector integer loads for a
data type narrower than `vemaxw` are sign- or zero-extended to `vemaxw`
bits.  Vector integer loads for a data type wider than `vemaxw` cause an
illegal instruction exception.

==== unit-stride instructions
[source,asm]
----
    # vd destination, rs1 base address
    vlb     vd, rs1, vm
    vlbu    vd, rs1, vm
    
    vlh     vd, rs1, vm
    vlhu    vd, rs1, vm
    
    vlw     vd, rs1, vm
    vlwu    vd, rs1, vm
    
    vld     vd, rs1, vm
----

[NOTE]
Speculative versions for unit-stride loads only in base?

[NOTE]
Unit stride is a pseudo-op which is encoded as `x0` in the `rs2` field
of a constant stride instruction

==== constant-stride instructions
[source,asm]
----
    # vd destination, rs1 base address, rs2 byte stride
    vlsb    vd, offset(rs1), rs2, vm 
    vlsbu   vd, offset(rs1), rs2, vm
    
    vlsh    vd, offset(rs1), rs2, vm
    vlshu   vd, offset(rs1), rs2, vm
    
    vlsw    vd, offset(rs1), rs2, vm
    vlswu   vd, offset(rs1), rs2, vm
    
    vlsd    vd, offset(rs1), rs2, vm
----

The offset is encoded as an immediate (size TBD) that is then scaled
by the element size to give a byte offset.

The stride is interpreted as an integer representing a byte offset.

==== indexed (scatter-gather) instructions
[source,asm]
----
    # vd destination, rs1 base address, vs2 indices
    vlxb    vd, offset(rs1), vs2, vm
    vlxbu   vd, offset(rs1), vs2, vm
    
    vlxh    vd, offset(rs1), vs2, vm
    vlxhu   vd, offset(rs1), vs2, vm
    
    vlxw    vd, offset(rs1), vs2, vm
    vlxwu   vd, offset(rs1), vs2, vm
    
    vlxd    vd, offset(rs1), vs2, vm
----

The offset is encoded as an immediate (size TBD) that is then scaled
by the element size to give a byte offset.

Scatter/gather indices are treated as integers of width `vemaxw`
representing byte offsets.

=== Vector stores
Vector stores move data values as bits taken from the LSBs of the
source element.  Vector stores for a data type wider than `vemaxw` cause
an illegal instruction exception.

==== unit-stride store instructions
[source,asm]
----
    vsb     vs3, rs1, vm
    vsh     vs3, rs1, vm
    vsw     vs3, rs1, vm
    vsd     vs3, rs1, vm
----

==== constant-stride store instructions
[source,asm]
----
    vssb    vs3, offset(rs1), rs2, vm
    vssh    vs3, offset(rs1), rs2, vm
    vssw    vs3, offset(rs1), rs2, vm
    vssd    vs3, offset(rs1), rs2, vm
----

==== indexed store (scatter) instructions
[source,asm]
----
    vsxb    vs3, offset(rs1), vs2, vm
    vsxh    vs3, offset(rs1), vs2, vm
    vsxw    vs3, offset(rs1), vs2, vm
    vsxd    vs3, offset(rs1), vs2, vm
----

==== indexed-unordered (scatter-gather) instructions (not in base spec)
[source,asm]
----
    vsxub   vs3, offset(rs1), vs2, vm
    vsxuh   vs3, offset(rs1), vs2, vm
    vsxuw   vs3, offset(rs1), vs2, vm
    vsxud   vs3, offset(rs1), vs2, vm
----

==== indexed-reverse-ordered (scatter-gather) instructions (not in base spec)

[source,asm]
----
    vsxrb   vs3, offset(rs1), vs2, vm
    vsxrh   vs3, offset(rs1), vs2, vm
    vsxrw   vs3, offset(rs1), vs2, vm
    vsxrd   vs3, offset(rs1), vs2, vm
----

== Vector fixed-point instructions
The `vclip` instructions support fixed-point and block-floating-point
arithmetic.

These instructions extract a narrower result from a wider integer,
optionally rounding off lower-order bits, and saturating if the source
would overflow the result precision.  The rounding mode is encoded in
`vxrm`, and the saturation mode (clip, wrap) is encoded in `vxcm`.

The instructions encode the number of bits in destination format
(8, 16 or 32 bits), and whether the destination format is signed or
unsigned.
If the destination element width `vemaxw` is greater than the
destination format, the result is sign- or zero-extended to fill the
destination element if the destination format is signed or unsigned
respectively.

The first argument is the source value, the second value is the amount
by which it is shifted right to round off the lower order bits.

[source,asm]
----
    vclip.b     vd, vs1, vs2, vm
    vclip.h     vd, vs1, vs2, vm
    vclip.w     vd, vs1, vs2, vm

    vclip.bu    vd, vs1, vs2, vm
    vclip.hu    vd, vs1, vs2, vm
    vclip.wu    vd, vs1, vs2, vm
----

[NOTE]
The immediate forms were dropped to save encoding space.

=== Vector integer multiply and divides
==== Full-width multiply/divides
These are all equivalent to scalar integer multiply/divides, and
operate on `vemaxw` source and destination widths.

[source,asm]
----
    vmul            vd, vs1, vs2, vm
    vmulh           vd, vs1, vs2, vm
    vmulhsu         vd, vs1, vs2, vm
    vmulhu          vd, vs1, vs2, vm
    vdiv            vd, vs1, vs2, vm
    vdivu           vd, vs1, vs2, vm
    vrem            vd, vs1, vs2, vm
    vremu           vd, vs1, vs2, vm
----

== Integer Reduction operations (not in base spec)
These instructions take a vector shape as input and produce a scalar
shape.

[source,asm]
----
    vredsum         vd.s, vs1
    vredmax         vd.s, vs1
    vredmaxu        vd.s, vs1
    vredmin         vd.s, vs1
    vredminu        vd.s, vs1
    vredand         vd.s, vs1
    vredor          vd.s, vs1
    vredxor         vd.s, vs1
----

== Vector Floating-Point Compute
The vector floating-point extension includes vector versions of all
scalar floating-point operations, for the supported floating-point
precisions of half-precision (16b), single-precision (32b), and
double-precision (64b).

[NOTE]
Quad precision floating-point might be supportable in the base
encoding for machines with Q extension, but not clear this is best use
of base encoding.

=== Vector minimum element width
An illegal instruction exception is raised when trying to execute a
vector floating-point instruction for a precision that does not fit in
the current `vemaxw`.

=== Vector `NaN` Boxing
Vector floating-point operations follow the scalar floating-point NaN
boxing model, taking their operands from the low bits of each vector
register but checking the high bits for correct NaN boxing and
treating the value as a canonical NaN if not correctly NaN boxed.  A
vector floating-point operation that writes to a wider destination
register always NaN boxes the result (writing 1s to the high-order
bits).

=== Vector floating-point rounding mode

The vector arithmetic instructions only use the dynamic rounding mode
in `frm`.

=== Vector floating-point exception flags

Vector operations that cause floating-point exceptions set vector
flags in the existing scalar `fflags` bits in the `fcsr`.

=== Binary operations
The following produce and consume operands of the same floating-point precision:

[source,asm]
----
    vfadd.h         vd, vs1, vs2, vm
    vfadd.s         vd, vs1, vs2, vm
    vfadd.d         vd, vs1, vs2, vm
----

[source,asm]
----
    vfsub.h         vd, vs1, vs2, vm
    vfsub.s         vd, vs1, vs2, vm
    vfsub.d         vd, vs1, vs2, vm
----

[source,asm]
----
    vfmul.h         vd, vs1, vs2, vm
    vfmul.s         vd, vs1, vs2, vm
    vfmul.d         vd, vs1, vs2, vm
----

[source,asm]
----
    vfdiv.h         vd, vs1, vs2, vm
    vfdiv.s         vd, vs1, vs2, vm
    vfdiv.d         vd, vs1, vs2, vm
----

[source,asm]
----
    vfsgnj.h        vd, vs1, vs2, vm
    vfsgnj.s        vd, vs1, vs2, vm
    vfsgnj.d        vd, vs1, vs2, vm
----

[source,asm]
----
    vfsgnjn.h       vd, vs1, vs2, vm
    vfsgnjn.s       vd, vs1, vs2, vm
    vfsgnjn.d       vd, vs1, vs2, vm
----

[source,asm]
----
    vfsgnjx.h       vd, vs1, vs2, vm
    vfsgnjx.s       vd, vs1, vs2, vm
    vfsgnjx.d       vd, vs1, vs2, vm
----

[source,asm]
----
    vfmin.h         vd, vs1, vs2, vm
    vfmin.s         vd, vs1, vs2, vm
    vfmin.d         vd, vs1, vs2, vm
----

[source,asm]
----
    vfmax.h         vd, vs1, vs2, vm
    vfmax.s         vd, vs1, vs2, vm
    vfmax.d         vd, vs1, vs2, vm
----

The following compare instructions produce an integer binary value:

[source,asm]
----
    vfeq.h          vd, vs1, vs2, vm
    vfeq.s          vd, vs1, vs2, vm
    vfeq.d          vd, vs1, vs2, vm
----

[source,asm]
----
    vflt.h          vd, vs1, vs2, vm
    vflt.s          vd, vs1, vs2, vm
    vflt.d          vd, vs1, vs2, vm
----

[source,asm]
----
    vfle.h          vd, vs1, vs2, vm
    vfle.s          vd, vs1, vs2, vm
    vfle.d          vd, vs1, vs2, vm
----

==== Unary operators
[source,asm]
----
        vfsqrt.h        vd, vs1, vm
        vfsqrt.s        vd, vs1, vm
        vfsqrt.d        vd, vs1, vm
----
[source,asm]
----
        vfclass.h       vd, vs1, vm
        vfclass.s       vd, vs1, vm
        vfclass.d       vd, vs1, vm
----

==== Reduction operations (not in base spec)
These instructions take a vector shape as input and produce a scalar
shape.
Cannot mask the vector input, but can preprocess to get
correct result from a mask (e.g., zero masked elements before sum).
[source,asm]
----
    vredsum vd.s, vs1
----

[source,asm]
----
    vredmax vd.s, vs1
----

[source,asm]
----
    vredmin vd.s, vs1
----

==== Vector floating-point fused multiply-add

To save opcode space, don't include negating forms.
[source,asm]
----
    vfmadd.h vd, vs1, vs2, vs3, vm
    vfmadd.s vd, vs1, vs2, vs3, vm
    vfmadd.d vd, vs1, vs2, vs3, vm
----

[source,asm]
----
    vfmsub.h vd, vs1, vs2, vs3, vm
    vfmsub.s vd, vs1, vs2, vs3, vm
    vfmsub.d vd, vs1, vs2, vs3, vm
----

==== Vector Integer Convert instructions (not in base spec)
Use `.i` for signed integer type, and `.u` for unsigned integer type.

Convert integer to narrower integer
[source,asm]
----
    vcvt vd, vs1, vm 
----
Don't need unsigned source, as this doesn't affect conversion.

==== Convert integer to float
[source,asm]
----
    vfcvt.h.w vd, vs1, vm
    vfcvt.h.wu vd, vs1, vm
----

[source,asm]
----
    vfcvt.s.w vd, vs1, vm
    vfcvt.s.wu vd, vs1, vm
----

[source,asm]
----
    vfcvt.d.w vd, vs1, vm
    vfcvt.d.wu vd, vs1, vm
----

==== Convert float to integer
[source,asm]
----
    vfcvt.w.h vd, vs1, vm
    vfcvt.wu.h vd, vs1, vm
----

[source,asm]
----
    vfcvt.w.s vd, vs1, vm
    vfcvt.wu.s vd, vs1, vm
----

[source,asm]
----
    vfcvt.l.d vd, vs1, vm
    vfcvt.lu.d vd, vs1, vm
----
These all convert to `vemaxw` canonical integers.

Convert float to float
[source,asm]
----
    vfcvt.h.s vd, vs1, vm
    vfcvt.h.d vd, vs1, vm
----

[source,asm]
----
    vfcvt.s.h vd, vs1, vm
    vfcvt.s.d vd, vs1, vm
----

[source,asm]
----
    vfcvt.d.h vd, vs1, vm
    vfcvt.d.s vd, vs1, vm
----


== Vector Floating-Point Memory Operations

=== Vector Floating-Point Loads
Floating-point vector load instructions encode type

==== unit-stride instructions
[source,asm]
----
    vflh    vd, rs1, vm
    vflw    vd, rs1, vm
    vfld    vd, rs1, vm
----

==== constant-stride instructions
[source,asm]
----
    vflsh   vd, offset(rs1), rs2, vm
    vflsw   vd, offset(rs1), rs2, vm
    vflsd   vd, offset(rs1), rs2, vm
----

==== indexed (scatter-gather) instructions
[source,asm]
----
    vflxh   vd, offset(rs1), vs2, vm
    vflxw   vd, offset(rs1), vs2, vm
    vflxd   vd, offset(rs1), vs2, vm
----

=== Vector floating-point stores
These use the integer vector stores, reading data from the low bits of
the source vector register.


== Vector Register Element Movement Instructions

=== Move to/from floating-point (f) registers.
[source,asm]
----
    vfmv.v.f  vd, rs1, vm   # vd = rs1
    vfmv.f.v  rd, vs1       # rd = vs1[0]
----

Move one vector element as bits to/from FPRs.  If destination is
narrower than the source, only the least significant bits are copied
and the upper bits of source are ignored. If the destination is wider
than the source, the value is one-extended (high bits filled with 1s
to preserve NaN boxing).  All vector masking options are available for
vfmv.v.f

Insert/extract elements between x and vector registers,
[source,asm]
----
    vinsert vd, rs1, rs2, vm  # vd[rs2] = rs1
    vextract rd, vs1, rs2      # rd = vs1[rs2]
----

Move one vector element as bits to/from GPRs (called insert/extract in
current space).  If destination is narrower than the source, only the
least significant bits are copied and the upper bits of source are
ignored. If the destination is wider than the source, the value is
sign-extended.  All vector masking options are available for `vinsert`.

If `rs2 > MAXVL`, `vinsert` does nothing.
If `rs2 > MAXVL`, `vextract` returns `0`.

On archs with reg renaming or ECC, instructions that write single
elements to a vector register will have to read old dest and merge in
new value.  These instructions have only a single vector source, so
can use second/third read port to read `vd`.

=== Vector merge
[source,asm]
----
    vmerge  vd, vs1, vs2,  vm   # vd[i] = vm[i] ? vs1[i] : vs2[i]
    vmergex vd, rs1, vs2,  vm   # vd[i] = vm[i] ? rs1    : vs2[i]
----

Mask picks between first and second operand to be written to
destination register.  Scalar shape version copies first operand to
destination.

=== Vector register gather
[source,asm]
----
    vrgather vd, vs1, vs2, vm # vd[i] = vs1[vs2[i]]
----

Each destination element is extracted from selected location in source
vector.  If vs2[i] is out of range 0..MAXVL-1, then 0 is returned.

=== Vector register slide
[source,asm]
----
    vslide vd, vs1, rs2, vm  # vd[i] = vs1[rs2+i]
----

Writes vl elements to destination vector register taken from start
index `rs2` in source vector.  If `rs2 + i >= MAXVL`, returns 0s.

All masking operations are available on vslide. Will splat just
vs1[rs2] to all of vd if destination is scalar shape.

=== Vector mask to xreg instructions

[source,asm]
----
    vmfirst rd, vs1
----
Writes rd with the index of the element in vs1 with the first set `LSB`,
or `-1` if no bits set in v0.

[source,asm]
----
    vmpopc rd, vs1
----

Writes rd with the sum of the set LSBs in the first vl elements of
vs1.

=== Vector Select Instruction (IOTA)

[source,asm]
----
vselect vd, vm    # Count bits in preceding mask elements.
----

[source,C]
----
// Pseudo code when vm=v0.true
s = 0;

for (i = 0; i < vl; ++i) {
    vd[i]=s;  // Results wrap around (truncate high bits) if too large for destination elements.
    s += vm[i].lsb;  // Count set bits in mask
}

for ( ; i < MAXVL; ++i) {
    vd[i]=0;
}
----


With `vm == scalar`, writes vd.s with 0.
With `vm == true`, writes vd[i] with index i.
With `vm == v0.false`, counts zero bits
With `vm == v0.true`, counts one bits

[source,C]
----
// Pseudo code when vm=v0.true
s = 0;

for (i=0; i < vl; ++i) {
    vd[i]=s;  // Results wrap around (truncate high bits) if too large for destination elements.
    s += vm[i].lsb;  // Count set bits in mask
}

for ( ; i<MAXVL; ++i) {
    vd[i]=0;
}
----


==== Mask operations to support software vector-length speculation (not in the base spec)
[source,asm]
----
    vmfbf vd, vs1, vm  # Flag before first.
    vmfif vd, vs1, vm  # Flag including first.
    vmfof vd, vs1, vm  # Flag only first.
----

----
00011001  vs1.lsbs
11100000  fbf
11110000  fif
00010000  fof
----

[source,c]
----
// vmfbf psuedo code 
s = 1;

for (i = 0; i < vl; ++i) {
    if(v0[i].lsb) {
        if (vs1[i].lsb) {
            s = 0;
        }
        vd[i] = s[i].lsb;
    } else {
        vd[i] = 0;
    }
}

for ( ; i < MAXVL; ++i) {
    vd[i] = 0;
}
----

[source,c]
----
// vmfif psuedo code when vm=v0.true
s = 1;

for (i = 0; i < vl; ++i) {
    if(v0[i].lsb) {
        vd[i] = s;
        if (vs1[i].lsb) {
            s = 0;
        }
    } else {
        vd[i] = 0;
    }
}

for ( ; i < MAXVL; ++i) {
    vd[i] = 0;
}
----

[source,c]
----
// vmfof psuedo code when vm=v0.true
s = 1;

for (i = 0; i < vl; ++i) {
    if(v0[i].lsb) {
        if (vm[i].lsb) {
            vd[i]=s;
            s=0;
        } else {
            vd[i]=0;
        } 
    } else {
        vd[i]=0;
    }
}

for ( ; i < MAXVL; ++i) {
    vd[i] = 0;
}
----

== Base Vector Instruction Encoding
include::inst-table.adoc[]
